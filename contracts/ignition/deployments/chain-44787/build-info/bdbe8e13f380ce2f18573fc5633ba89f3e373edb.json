{
  "_format": "hh3-sol-build-info-1",
  "id": "bdbe8e13f380ce2f18573fc5633ba89f3e373edb",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/UserVerification.sol": "project/contracts/UserVerification.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.0/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.0/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.0/",
        "project/:@selfxyz/contracts/=npm/@selfxyz/contracts@1.2.0/"
      ]
    },
    "sources": {
      "npm/@selfxyz/contracts@1.2.0/contracts/abstract/SelfVerificationRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IIdentityVerificationHubV2} from \"../interfaces/IIdentityVerificationHubV2.sol\";\nimport {ISelfVerificationRoot} from \"../interfaces/ISelfVerificationRoot.sol\";\nimport {CircuitConstantsV2} from \"../constants/CircuitConstantsV2.sol\";\nimport {AttestationId} from \"../constants/AttestationId.sol\";\n\n/**\n * @title SelfVerificationRoot\n * @notice Abstract base contract to be integrated with self's verification infrastructure\n * @dev Provides base functionality for verifying and disclosing identity credentials\n * @author Self Team\n */\nabstract contract SelfVerificationRoot is ISelfVerificationRoot {\n    // ====================================================\n    // Constants\n    // ====================================================\n\n    /// @notice Contract version identifier used in verification process\n    /// @dev This version is included in the hub data for protocol compatibility\n    uint8 constant CONTRACT_VERSION = 2;\n\n    // ====================================================\n    // Storage Variables\n    // ====================================================\n\n    /// @notice The scope value that proofs must match\n    /// @dev Used to validate that submitted proofs match the expected scope\n    uint256 internal _scope;\n\n    /// @notice Reference to the identity verification hub V2 contract\n    /// @dev Immutable reference used for bytes-based proof verification\n    IIdentityVerificationHubV2 internal immutable _identityVerificationHubV2;\n\n    // ====================================================\n    // Errors\n    // ====================================================\n\n    /// @notice Error thrown when the data format is invalid\n    /// @dev Triggered when the provided bytes data doesn't have the expected format\n    error InvalidDataFormat();\n\n    /// @notice Error thrown when onVerificationSuccess is called by an unauthorized address\n    /// @dev Only the identity verification hub V2 contract can call onVerificationSuccess\n    error UnauthorizedCaller();\n\n    // ====================================================\n    // Events\n    // ====================================================\n\n    /// @notice Emitted when the scope is updated\n    /// @param newScope The new scope value that was set\n    event ScopeUpdated(uint256 indexed newScope);\n\n    /**\n     * @notice Initializes the SelfVerificationRoot contract\n     * @dev Sets up the immutable reference to the hub contract and initial scope\n     * @param identityVerificationHubV2Address The address of the Identity Verification Hub V2\n     * @param scopeValue The expected proof scope for user registration\n     */\n    constructor(address identityVerificationHubV2Address, uint256 scopeValue) {\n        _identityVerificationHubV2 = IIdentityVerificationHubV2(identityVerificationHubV2Address);\n        _scope = scopeValue;\n    }\n\n    /**\n     * @notice Returns the current scope value\n     * @dev Public view function to access the current scope setting\n     * @return The scope value that proofs must match\n     */\n    function scope() public view returns (uint256) {\n        return _scope;\n    }\n\n    /**\n     * @notice Updates the scope value\n     * @dev Protected internal function to change the expected scope for proofs\n     * @param newScope The new scope value to set\n     */\n    function _setScope(uint256 newScope) internal {\n        _scope = newScope;\n        emit ScopeUpdated(newScope);\n    }\n\n    /**\n     * @notice Verifies a self-proof using the bytes-based interface\n     * @dev Parses relayer data format and validates against contract settings before calling hub V2\n     * @param proofPayload Packed data from relayer in format: | 32 bytes attestationId | proof data |\n     * @param userContextData User-defined data in format: | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     * @custom:data-format proofPayload = | 32 bytes attestationId | proofData |\n     * @custom:data-format userContextData = | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     * @custom:data-format hubData = | 1 bytes contract version | 31 bytes buffer | 32 bytes scope | 32 bytes attestationId | proofData |\n     */\n    function verifySelfProof(bytes calldata proofPayload, bytes calldata userContextData) public {\n        // Minimum expected length for proofData: 32 bytes attestationId + proof data\n        if (proofPayload.length < 32) {\n            revert InvalidDataFormat();\n        }\n\n        // Minimum userDefinedData length: 32 (destChainId) + 32 (userIdentifier) + 0 (userDefinedData) = 64 bytes\n        if (userContextData.length < 64) {\n            revert InvalidDataFormat();\n        }\n\n        bytes32 attestationId;\n        assembly {\n            // Load attestationId from the beginning of proofData (first 32 bytes)\n            attestationId := calldataload(proofPayload.offset)\n        }\n\n        bytes32 destinationChainId = bytes32(userContextData[0:32]);\n        bytes32 userIdentifier = bytes32(userContextData[32:64]);\n        bytes memory userDefinedData = userContextData[64:];\n\n        bytes32 configId = getConfigId(destinationChainId, userIdentifier, userDefinedData);\n\n        // Hub data should be | 1 byte contractVersion | 31 bytes buffer | 32 bytes scope | 32 bytes attestationId | proof data\n        bytes memory baseVerificationInput = abi.encodePacked(\n            // 1 byte contractVersion\n            CONTRACT_VERSION,\n            // 31 bytes buffer (all zeros)\n            bytes31(0),\n            // 32 bytes scope\n            _scope,\n            // 32 bytes attestationId\n            attestationId,\n            // proof data (starts after 32 bytes attestationId)\n            proofPayload[32:]\n        );\n\n        // Call hub V2 verification\n        _identityVerificationHubV2.verify(baseVerificationInput, bytes.concat(configId, userContextData));\n    }\n\n    /**\n     * @notice Callback function called upon successful verification by the hub contract\n     * @dev Only callable by the identity verification hub V2 contract for security\n     * @param output The verification output data containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     * @custom:security Only the authorized hub contract can call this function\n     * @custom:flow This function decodes the output and calls the customizable verification hook\n     */\n    function onVerificationSuccess(bytes memory output, bytes memory userData) public {\n        // Only allow the identity verification hub V2 to call this function\n        if (msg.sender != address(_identityVerificationHubV2)) {\n            revert UnauthorizedCaller();\n        }\n\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory genericDiscloseOutput = abi.decode(\n            output,\n            (ISelfVerificationRoot.GenericDiscloseOutputV2)\n        );\n\n        // Call the customizable verification hook\n        customVerificationHook(genericDiscloseOutput, userData);\n    }\n\n    /**\n     * @notice Generates a configId for the user\n     * @dev This function should be overridden by the implementing contract to provide custom configId logic\n     * @param destinationChainId The destination chain ID\n     * @param userIdentifier The user identifier\n     * @param userDefinedData The user defined data\n     * @return The configId\n     */\n    function getConfigId(\n        bytes32 destinationChainId,\n        bytes32 userIdentifier,\n        bytes memory userDefinedData\n    ) public view virtual returns (bytes32) {\n        // Default implementation reverts; must be overridden in derived contract\n        revert(\"SelfVerificationRoot: getConfigId must be overridden\");\n    }\n\n    /**\n     * @notice Custom verification hook that can be overridden by implementing contracts\n     * @dev This function is called after successful verification and hub address validation\n     * @param output The verification output data from the hub containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     * @custom:override Override this function in derived contracts to add custom verification logic\n     * @custom:security This function is only called after proper authentication by the hub contract\n     */\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) internal virtual {\n        // Default implementation is empty - override in derived contracts to add custom logic\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/constants/AttestationId.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title AttestationId Library\n * @notice This library provides attestation identifiers used across contracts.\n * @dev Currently, it contains the constant E_PASSPORT which represents the identifier\n * for an E-PASSPORT attestation computed as Poseidon(\"E-PASSPORT\").\n */\nlibrary AttestationId {\n    /**\n     * @notice Identifier for an E-PASSPORT attestation.\n     * @dev The identifier is computed based on the hash of \"E-PASSPORT\" using the Poseidon hash function.\n     * Here it is hardcoded as bytes32(uint256(1)) for demonstration purposes.\n     */\n    bytes32 constant E_PASSPORT = bytes32(uint256(1));\n    bytes32 constant EU_ID_CARD = bytes32(uint256(2));\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/constants/CircuitConstantsV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {AttestationId} from \"./AttestationId.sol\";\n\n/**\n * @title Circuit Constants Library\n * @notice This library defines constants representing indices used to access public signals\n *         of various circuits such as register, DSC, and VC/Disclose.\n * @dev These indices map directly to specific data fields in the corresponding circuits proofs.\n */\nlibrary CircuitConstantsV2 {\n    // ---------------------------\n    // Register Circuit Constants\n    // ---------------------------\n\n    /**\n     * @notice Index to access the nullifier in the register circuit public signals.\n     */\n    uint256 constant REGISTER_NULLIFIER_INDEX = 0;\n\n    /**\n     * @notice Index to access the commitment in the register circuit public signals.\n     */\n    uint256 constant REGISTER_COMMITMENT_INDEX = 1;\n\n    /**\n     * @notice Index to access the Merkle root in the register circuit public signals.\n     */\n    uint256 constant REGISTER_MERKLE_ROOT_INDEX = 2;\n\n    // ---------------------------\n    // DSC Circuit Constants\n    // ---------------------------\n\n    /**\n     * @notice Index to access the tree leaf in the DSC circuit public signals.\n     */\n    uint256 constant DSC_TREE_LEAF_INDEX = 0;\n\n    /**\n     * @notice Index to access the CSCA root in the DSC circuit public signals.\n     */\n    uint256 constant DSC_CSCA_ROOT_INDEX = 1;\n\n    // -------------------------------------\n    // VC and Disclose Circuit Constants\n    // -------------------------------------\n\n    /**\n     * @notice Structure containing circuit indices for a specific attestation type.\n     */\n    struct DiscloseIndices {\n        uint256 revealedDataPackedIndex;\n        uint256 forbiddenCountriesListPackedIndex;\n        uint256 nullifierIndex;\n        uint256 attestationIdIndex;\n        uint256 merkleRootIndex;\n        uint256 currentDateIndex;\n        uint256 namedobSmtRootIndex;\n        uint256 nameyobSmtRootIndex;\n        uint256 scopeIndex;\n        uint256 userIdentifierIndex;\n        uint256 passportNoSmtRootIndex; // Only for passport, 99 for ID card\n    }\n\n    /**\n     * @notice Returns the circuit indices for a given attestation type.\n     * @param attestationId The attestation identifier.\n     * @return indices The DiscloseIndices struct containing all relevant indices.\n     */\n    function getDiscloseIndices(bytes32 attestationId) internal pure returns (DiscloseIndices memory indices) {\n        if (attestationId == AttestationId.E_PASSPORT) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 0,\n                    forbiddenCountriesListPackedIndex: 3,\n                    nullifierIndex: 7,\n                    attestationIdIndex: 8,\n                    merkleRootIndex: 9,\n                    currentDateIndex: 10,\n                    namedobSmtRootIndex: 17,\n                    nameyobSmtRootIndex: 18,\n                    scopeIndex: 19,\n                    userIdentifierIndex: 20,\n                    passportNoSmtRootIndex: 16\n                });\n        } else if (attestationId == AttestationId.EU_ID_CARD) {\n            return\n                DiscloseIndices({\n                    revealedDataPackedIndex: 0,\n                    forbiddenCountriesListPackedIndex: 4,\n                    nullifierIndex: 8,\n                    attestationIdIndex: 9,\n                    merkleRootIndex: 10,\n                    currentDateIndex: 11,\n                    namedobSmtRootIndex: 17,\n                    nameyobSmtRootIndex: 18,\n                    scopeIndex: 19,\n                    userIdentifierIndex: 20,\n                    passportNoSmtRootIndex: 99\n                });\n        } else {\n            revert(\"Invalid attestation ID\");\n        }\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/interfaces/IDscCircuitVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title IDscCircuitVerifier\n * @notice Interface for verifying zero-knowledge proofs related to the DSC circuit.\n * @dev This interface defines the structure of a DSC circuit proof and exposes a function to verify such proofs.\n */\ninterface IDscCircuitVerifier {\n    /**\n     * @notice Represents a DSC circuit proof.\n     * @param a An array of two unsigned integers representing the proof component 'a'.\n     * @param b A 2x2 array of unsigned integers representing the proof component 'b'.\n     * @param c An array of two unsigned integers representing the proof component 'c'.\n     * @param pubSignals An array of two unsigned integers representing the public signals associated with the proof.\n     */\n    struct DscCircuitProof {\n        uint[2] a;\n        uint[2][2] b;\n        uint[2] c;\n        uint[2] pubSignals;\n    }\n\n    /**\n     * @notice Verifies a given DSC circuit zero-knowledge proof.\n     * @dev This function checks the validity of the provided DSC proof parameters.\n     * @param pA The 'a' component of the proof.\n     * @param pB The 'b' component of the proof.\n     * @param pC The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint[2] calldata pA,\n        uint[2][2] calldata pB,\n        uint[2] calldata pC,\n        uint[2] calldata pubSignals\n    ) external view returns (bool);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/interfaces/IIdentityVerificationHubV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {IRegisterCircuitVerifier} from \"./IRegisterCircuitVerifier.sol\";\nimport {IDscCircuitVerifier} from \"./IDscCircuitVerifier.sol\";\nimport {SelfStructs} from \"../libraries/SelfStructs.sol\";\n\n/**\n * @title IIdentityVerificationHubV2\n * @notice Interface for the Identity Verification Hub V2 for verifying zero-knowledge proofs.\n * @dev Defines all external and public functions from IdentityVerificationHubImplV2.\n */\ninterface IIdentityVerificationHubV2 {\n    // ====================================================\n    // External Functions\n    // ====================================================\n\n    /**\n     * @notice Registers a commitment using a register circuit proof.\n     * @dev Verifies the register circuit proof and then calls the Identity Registry to register the commitment.\n     * @param attestationId The attestation ID.\n     * @param registerCircuitVerifierId The identifier for the register circuit verifier to use.\n     * @param registerCircuitProof The register circuit proof data.\n     */\n    function registerCommitment(\n        bytes32 attestationId,\n        uint256 registerCircuitVerifierId,\n        IRegisterCircuitVerifier.RegisterCircuitProof memory registerCircuitProof\n    ) external;\n\n    /**\n     * @notice Registers a DSC key commitment using a DSC circuit proof.\n     * @dev Verifies the DSC proof and then calls the Identity Registry to register the dsc key commitment.\n     * @param attestationId The attestation ID.\n     * @param dscCircuitVerifierId The identifier for the DSC circuit verifier to use.\n     * @param dscCircuitProof The DSC circuit proof data.\n     */\n    function registerDscKeyCommitment(\n        bytes32 attestationId,\n        uint256 dscCircuitVerifierId,\n        IDscCircuitVerifier.DscCircuitProof memory dscCircuitProof\n    ) external;\n\n    /**\n     * @notice Sets verification config in V2 storage (owner only)\n     * @dev The configId is automatically generated from the config content using sha256(abi.encode(config))\n     * @param config The verification configuration\n     * @return configId The generated config ID\n     */\n    function setVerificationConfigV2(\n        SelfStructs.VerificationConfigV2 memory config\n    ) external returns (bytes32 configId);\n\n    /**\n     * @notice Main verification function with new structured input format\n     * @param baseVerificationInput The base verification input data\n     * @param userContextData The user context data\n     */\n    function verify(bytes calldata baseVerificationInput, bytes calldata userContextData) external;\n\n    /**\n     * @notice Updates the registry address.\n     * @param attestationId The attestation ID.\n     * @param registryAddress The new registry address.\n     */\n    function updateRegistry(bytes32 attestationId, address registryAddress) external;\n\n    /**\n     * @notice Updates the VC and Disclose circuit verifier address.\n     * @param attestationId The attestation ID.\n     * @param vcAndDiscloseCircuitVerifierAddress The new VC and Disclose circuit verifier address.\n     */\n    function updateVcAndDiscloseCircuit(bytes32 attestationId, address vcAndDiscloseCircuitVerifierAddress) external;\n\n    /**\n     * @notice Updates the register circuit verifier for a specific signature type.\n     * @param attestationId The attestation identifier.\n     * @param typeId The signature type identifier.\n     * @param verifierAddress The new register circuit verifier address.\n     */\n    function updateRegisterCircuitVerifier(bytes32 attestationId, uint256 typeId, address verifierAddress) external;\n\n    /**\n     * @notice Updates the DSC circuit verifier for a specific signature type.\n     * @param attestationId The attestation identifier.\n     * @param typeId The signature type identifier.\n     * @param verifierAddress The new DSC circuit verifier address.\n     */\n    function updateDscVerifier(bytes32 attestationId, uint256 typeId, address verifierAddress) external;\n\n    /**\n     * @notice Batch updates register circuit verifiers.\n     * @param attestationIds An array of attestation identifiers.\n     * @param typeIds An array of signature type identifiers.\n     * @param verifierAddresses An array of new register circuit verifier addresses.\n     */\n    function batchUpdateRegisterCircuitVerifiers(\n        bytes32[] calldata attestationIds,\n        uint256[] calldata typeIds,\n        address[] calldata verifierAddresses\n    ) external;\n\n    /**\n     * @notice Batch updates DSC circuit verifiers.\n     * @param attestationIds An array of attestation identifiers.\n     * @param typeIds An array of signature type identifiers.\n     * @param verifierAddresses An array of new DSC circuit verifier addresses.\n     */\n    function batchUpdateDscCircuitVerifiers(\n        bytes32[] calldata attestationIds,\n        uint256[] calldata typeIds,\n        address[] calldata verifierAddresses\n    ) external;\n\n    // ====================================================\n    // External View Functions\n    // ====================================================\n\n    /**\n     * @notice Returns the registry address for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The registry address associated with the attestation ID.\n     */\n    function registry(bytes32 attestationId) external view returns (address);\n\n    /**\n     * @notice Returns the disclose verifier address for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The disclose verifier address associated with the attestation ID.\n     */\n    function discloseVerifier(bytes32 attestationId) external view returns (address);\n\n    /**\n     * @notice Returns the register circuit verifier address for a given attestation ID and type ID.\n     * @param attestationId The attestation ID to query.\n     * @param typeId The type ID to query.\n     * @return The register circuit verifier address associated with the attestation ID and type ID.\n     */\n    function registerCircuitVerifiers(bytes32 attestationId, uint256 typeId) external view returns (address);\n\n    /**\n     * @notice Returns the DSC circuit verifier address for a given attestation ID and type ID.\n     * @param attestationId The attestation ID to query.\n     * @param typeId The type ID to query.\n     * @return The DSC circuit verifier address associated with the attestation ID and type ID.\n     */\n    function dscCircuitVerifiers(bytes32 attestationId, uint256 typeId) external view returns (address);\n\n    /**\n     * @notice Returns the merkle root timestamp for a given attestation ID and root.\n     * @param attestationId The attestation ID to query.\n     * @param root The merkle root to query.\n     * @return The merkle root timestamp associated with the attestation ID and root.\n     */\n    function rootTimestamp(bytes32 attestationId, uint256 root) external view returns (uint256);\n\n    /**\n     * @notice Returns the identity commitment merkle root for a given attestation ID.\n     * @param attestationId The attestation ID to query.\n     * @return The identity commitment merkle root associated with the attestation ID.\n     */\n    function getIdentityCommitmentMerkleRoot(bytes32 attestationId) external view returns (uint256);\n\n    /**\n     * @notice Checks if a verification config exists\n     * @param configId The configuration identifier\n     * @return exists Whether the config exists\n     */\n    function verificationConfigV2Exists(bytes32 configId) external view returns (bool exists);\n\n    // ====================================================\n    // Public Functions\n    // ====================================================\n\n    /**\n     * @notice Generates a config ID from a verification config\n     * @param config The verification configuration\n     * @return The generated config ID (sha256 hash of encoded config)\n     */\n    function generateConfigId(SelfStructs.VerificationConfigV2 memory config) external pure returns (bytes32);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/interfaces/IRegisterCircuitVerifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n/**\n * @title IRegisterCircuitVerifier\n * @notice Interface for verifying register circuit proofs.\n * @dev This interface defines the structure of a register circuit proof and exposes a function to verify such proofs.\n */\ninterface IRegisterCircuitVerifier {\n    /**\n     * @notice Represents a register circuit proof.\n     * @dev This structure encapsulates the required proof elements.\n     * @param a An array of two unsigned integers representing the proof component 'a'.\n     * @param b A 2x2 array of unsigned integers representing the proof component 'b'.\n     * @param c An array of two unsigned integers representing the proof component 'c'.\n     * @param pubSignals An array of three unsigned integers representing the public signals associated with the proof.\n     */\n    struct RegisterCircuitProof {\n        uint[2] a;\n        uint[2][2] b;\n        uint[2] c;\n        uint[3] pubSignals;\n    }\n\n    /**\n     * @notice Verifies a given register circuit proof.\n     * @dev This function checks the validity of the provided proof parameters.\n     * @param a The 'a' component of the proof.\n     * @param b The 'b' component of the proof.\n     * @param c The 'c' component of the proof.\n     * @param pubSignals The public signals associated with the proof.\n     * @return isValid A boolean value indicating whether the provided proof is valid (true) or not (false).\n     */\n    function verifyProof(\n        uint[2] calldata a,\n        uint[2][2] calldata b,\n        uint[2] calldata c,\n        uint[3] calldata pubSignals\n    ) external view returns (bool isValid);\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/interfaces/ISelfVerificationRoot.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title ISelfVerificationRoot\n * @notice Interface for self-verification infrastructure integration\n * @dev Provides base functionality for verifying and disclosing identity credentials\n */\ninterface ISelfVerificationRoot {\n    /**\n     * @notice Structure containing proof data for disclose circuits\n     * @dev Contains the proof elements required for zero-knowledge verification\n     * @param a First proof element\n     * @param b Second proof element (2x2 matrix)\n     * @param c Third proof element\n     * @param pubSignals Array of 21 public signals for the circuit\n     */\n    struct DiscloseCircuitProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[21] pubSignals;\n    }\n\n    /**\n     * @notice Structure containing verified identity disclosure output data\n     * @dev Contains all disclosed identity information after successful verification\n     * @param attestationId Unique identifier for the identity documents\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Unique nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed representation of forbidden countries list\n     * @param issuingState The state/country that issued the identity document\n     * @param name Array of name components\n     * @param idNumber The identity document number\n     * @param nationality The nationality of the document holder\n     * @param dateOfBirth Date of birth in string format\n     * @param gender Gender of the document holder\n     * @param expiryDate Expiry date of the identity document\n     * @param olderThan Verified age threshold (e.g., 18 for adult verification)\n     * @param ofac Array of OFAC (Office of Foreign Assets Control) compliance flags\n     */\n    struct GenericDiscloseOutputV2 {\n        bytes32 attestationId;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n        string issuingState;\n        string[] name;\n        string idNumber;\n        string nationality;\n        string dateOfBirth;\n        string gender;\n        string expiryDate;\n        uint256 olderThan;\n        bool[3] ofac;\n    }\n\n    /**\n     * @notice Verifies a self-proof using the bytes-based interface\n     * @dev Parses relayer data format and validates against contract settings before calling hub V2\n     * @param proofPayload Packed data from relayer in format: | 32 bytes attestationId | proof data |\n     * @param userContextData User-defined data in format: | 32 bytes configId | 32 bytes destChainId | 32 bytes userIdentifier | data |\n     */\n    function verifySelfProof(bytes calldata proofPayload, bytes calldata userContextData) external;\n\n    /**\n     * @notice Callback function called upon successful verification\n     * @dev Only the identity verification hub V2 contract should call this function\n     * @param output The verification output data containing disclosed identity information\n     * @param userData The user-defined data passed through the verification process\n     */\n    function onVerificationSuccess(bytes memory output, bytes memory userData) external;\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/libraries/Formatter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title Formatter Library\n * @notice A library providing utility functions to format names, dates, and encode data.\n */\nlibrary Formatter {\n    error InvalidDateLength();\n    error InvalidYearRange();\n    error InvalidMonthRange();\n    error InvalidDayRange();\n    error InvalidFieldElement();\n    error InvalidDateDigit();\n\n    uint256 constant MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 40;\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /**\n     * @notice Formats a full name string into first name(s) and last name.\n     * @dev The input is expected to contain a last name, followed by a \"<<\" separator and then first name(s).\n     *      The returned array contains the first names at index 0 and the last name at index 1.\n     * @param input The input string structured as \"lastName<<firstName(s)\".\n     * @return names An array of two strings: [firstName(s), lastName].\n     */\n    function formatName(string memory input) internal pure returns (string[] memory) {\n        bytes memory inputBytes = bytes(input);\n        bytes memory firstNameBytes;\n        bytes memory lastNameBytes;\n        string[] memory names = new string[](2);\n\n        uint i = 0;\n        // Extract last name\n        while (i < inputBytes.length && inputBytes[i] != \"<\") {\n            lastNameBytes = abi.encodePacked(lastNameBytes, inputBytes[i]);\n            i++;\n        }\n\n        // Skip the separator \"<<\".\n        i += 2;\n\n        // Extract first names.\n        while (i < inputBytes.length) {\n            if (inputBytes[i] == \"<\") {\n                if (i + 1 < inputBytes.length && inputBytes[i + 1] == \"<\") {\n                    break;\n                }\n                firstNameBytes = abi.encodePacked(firstNameBytes, \" \");\n            } else {\n                firstNameBytes = abi.encodePacked(firstNameBytes, inputBytes[i]);\n            }\n            i++;\n        }\n\n        names[0] = string(firstNameBytes);\n        names[1] = string(lastNameBytes);\n        return names;\n    }\n\n    /**\n     * @notice Formats a compact date string into a human-readable date.\n     * @dev Expects the input date string to have exactly 6 characters in YYMMDD format.\n     *      Returns the date in \"DD-MM-YY\" format.\n     * @param date A string representing the date in YYMMDD format.\n     * @return A formatted date string in the format \"DD-MM-YY\".\n     */\n    function formatDate(string memory date) internal pure returns (string memory) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 6) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[2] > \"1\" || (dateBytes[2] == \"1\" && dateBytes[3] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[4] > \"3\" || (dateBytes[4] == \"3\" && dateBytes[5] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        string memory year = substring(date, 0, 2);\n        string memory month = substring(date, 2, 4);\n        string memory day = substring(date, 4, 6);\n\n        return string(abi.encodePacked(day, \"-\", month, \"-\", year));\n    }\n\n    /**\n     * @notice Converts an ASCII numeral code to its corresponding unsigned integer.\n     * @dev The input must represent an ASCII code for digits (0-9), i.e. between 48 and 57.\n     *      Reverts with InvalidAsciiCode if the input is out of range.\n     * @param numAscii The ASCII code of a digit character.\n     * @return The numeric value (0-9) corresponding to the ASCII code.\n     */\n    function numAsciiToUint(uint256 numAscii) internal pure returns (uint256) {\n        return (numAscii - 48);\n    }\n\n    /**\n     * @notice Converts an array of three field elements into a bytes representation.\n     * @dev Each element is converted into a specific number of bytes: 31, 31, and 31 respectively.\n     * @param publicSignals An array of three unsigned integers representing field elements.\n     * @return bytesArray A bytes array of total length 93 that encodes the three field elements.\n     */\n    function fieldElementsToBytes(uint256[3] memory publicSignals) internal pure returns (bytes memory) {\n        if (\n            publicSignals[0] >= SNARK_SCALAR_FIELD ||\n            publicSignals[1] >= SNARK_SCALAR_FIELD ||\n            publicSignals[2] >= SNARK_SCALAR_FIELD\n        ) {\n            revert InvalidFieldElement();\n        }\n        uint8[3] memory bytesCount = [31, 31, 31];\n        bytes memory bytesArray = new bytes(93);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 3; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n        return bytesArray;\n    }\n\n    function fieldElementsToBytesIdCard(uint256[4] memory publicSignals) internal pure returns (bytes memory) {\n        if (\n            publicSignals[0] >= SNARK_SCALAR_FIELD ||\n            publicSignals[1] >= SNARK_SCALAR_FIELD ||\n            publicSignals[2] >= SNARK_SCALAR_FIELD ||\n            publicSignals[3] >= SNARK_SCALAR_FIELD\n        ) {\n            revert InvalidFieldElement();\n        }\n        uint8[4] memory bytesCount = [31, 31, 31, 1];\n        bytes memory bytesArray = new bytes(94);\n\n        uint256 index = 0;\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 element = publicSignals[i];\n            for (uint8 j = 0; j < bytesCount[i]; j++) {\n                bytesArray[index++] = bytes1(uint8(element & 0xff));\n                element = element >> 8;\n            }\n        }\n        return bytesArray;\n    }\n\n    /**\n     * @notice Extracts forbidden country codes from a packed uint256.\n     * @dev Each forbidden country is represented by 3 bytes in the packed data.\n     *      The function extracts up to MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH forbidden countries.\n     * @param publicSignals A packed uint256 containing encoded forbidden country data.\n     * @return forbiddenCountries An array of strings representing the forbidden country codes.\n     */\n    // TODO: look at this function a bit\n    function extractForbiddenCountriesFromPacked(\n        uint256[4] memory publicSignals\n    ) internal pure returns (string[MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH] memory forbiddenCountries) {\n        for (uint256 i = 0; i < 4; i++) {\n            if (publicSignals[i] >= SNARK_SCALAR_FIELD) {\n                revert InvalidFieldElement();\n            }\n        }\n\n        for (uint256 j = 0; j < MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH; j++) {\n            uint256 byteIndex = (j * 3) % 93;\n            uint256 index = j / 31;\n\n            if (byteIndex + 2 < 31) {\n                uint256 shift = byteIndex * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[index * 3] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            } else if (byteIndex < 31) {\n                uint256 part0 = (publicSignals[0] >> (byteIndex * 8));\n                uint256 part1 = publicSignals[1] & 0x00ffff;\n                uint256 reversedPart1 = ((part1 & 0xff) << 8) | ((part1 & 0xff00) >> 8);\n                uint256 combined = reversedPart1 | (part0 << 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(combined)));\n            } else if (byteIndex + 2 < 62) {\n                uint256 byteIndexIn1 = byteIndex - 31;\n                uint256 shift = byteIndexIn1 * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[1] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            } else if (byteIndex < 62) {\n                uint256 part0 = (publicSignals[1] >> ((byteIndex - 31) * 8)) & 0x00ffff;\n                uint256 reversedPart0 = ((part0 & 0xff) << 8) | ((part0 & 0xff00) >> 8);\n                uint256 part1 = publicSignals[2] & 0x0000ff;\n                uint256 combined = part1 | (reversedPart0 << 8);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(combined)));\n            } else if (byteIndex < 93) {\n                uint256 byteIndexIn1 = byteIndex - 62;\n                uint256 shift = byteIndexIn1 * 8;\n                uint256 mask = 0xFFFFFF;\n                uint256 packedData = (publicSignals[2] >> shift) & mask;\n                uint256 reversedPackedData = ((packedData & 0xff) << 16) |\n                    ((packedData & 0xff00)) |\n                    ((packedData & 0xff0000) >> 16);\n                forbiddenCountries[j] = string(abi.encodePacked(uint24(reversedPackedData)));\n            }\n        }\n\n        return forbiddenCountries;\n    }\n\n    /**\n     * @notice Converts an array of 6 numerical values representing a date into a Unix timestamp.\n     * @dev Each element in the dateNum array is taken modulo 10, converted to its ASCII digit,\n     *      and concatenated to form a date string in YYMMDD format. This string is then converted\n     *      into a Unix timestamp using dateToUnixTimestamp.\n     * @param dateNum An array of 6 unsigned integers representing a date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the provided date.\n     */\n    function proofDateToUnixTimestamp(uint256[6] memory dateNum) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 6; i++) {\n            if (dateNum[i] > 9) {\n                revert InvalidDateDigit();\n            }\n        }\n        string memory date = \"\";\n        for (uint256 i = 0; i < 6; i++) {\n            date = string(abi.encodePacked(date, bytes1(uint8(48 + (dateNum[i] % 10)))));\n        }\n        uint256 currentTimestamp = dateToUnixTimestamp(date);\n        return currentTimestamp;\n    }\n\n    /**\n     * @notice Converts a date string in YYMMDD format into a Unix timestamp.\n     * @dev Parses the date string by extracting year, month, and day components using substring,\n     *      converts each component to an integer, and then computes the timestamp via toTimestamp.\n     *      Reverts if the input string is not exactly 6 characters long.\n     * @param date A 6-character string representing the date in YYMMDD format.\n     * @return timestamp The Unix timestamp corresponding to the input date.\n     */\n    function dateToUnixTimestamp(string memory date) internal pure returns (uint256) {\n        bytes memory dateBytes = bytes(date);\n        if (dateBytes.length != 6) {\n            revert InvalidDateLength();\n        }\n\n        if (dateBytes[2] > \"1\" || (dateBytes[2] == \"1\" && dateBytes[3] > \"2\")) {\n            revert InvalidMonthRange();\n        }\n\n        if (dateBytes[4] > \"3\" || (dateBytes[4] == \"3\" && dateBytes[5] > \"1\")) {\n            revert InvalidDayRange();\n        }\n\n        uint256 year = parseDatePart(substring(date, 0, 2)) + 2000;\n        uint256 month = parseDatePart(substring(date, 2, 4));\n        uint256 day = parseDatePart(substring(date, 4, 6));\n\n        return toTimestamp(year, month, day);\n    }\n\n    /**\n     * @notice Extracts a substring from a given string.\n     * @dev Returns the substring from startIndex (inclusive) to endIndex (exclusive).\n     * @param str The input string.\n     * @param startIndex The starting index of the substring (inclusive).\n     * @param endIndex The ending index of the substring (exclusive).\n     * @return The resulting substring.\n     */\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex - startIndex);\n\n        for (uint i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n\n        return string(result);\n    }\n\n    /**\n     * @notice Parses a numeric string and returns its unsigned integer representation.\n     * @dev Assumes the input string contains only numeric characters.\n     * @param value The string representing a number.\n     * @return result The parsed unsigned integer.\n     */\n    function parseDatePart(string memory value) internal pure returns (uint) {\n        bytes memory tempEmptyStringTest = bytes(value);\n        if (tempEmptyStringTest.length == 0) {\n            return 0;\n        }\n\n        uint digit;\n        uint result;\n        for (uint i = 0; i < tempEmptyStringTest.length; i++) {\n            digit = uint8(tempEmptyStringTest[i]) - 48;\n            result = result * 10 + digit;\n        }\n        return result;\n    }\n\n    /**\n     * @notice Converts a specific date into a Unix timestamp.\n     * @dev Calculates the timestamp by summing the number of days for years, months, and days since January 1, 1970.\n     *      Takes leap years into account during the calculation.\n     * @param year The full year (e.g., 2023).\n     * @param month The month (1-12).\n     * @param day The day of the month.\n     * @return timestamp The Unix timestamp corresponding to the given date.\n     */\n    function toTimestamp(uint256 year, uint256 month, uint256 day) internal pure returns (uint timestamp) {\n        uint16 i;\n\n        if (year < 1970 || year > 2100) {\n            revert InvalidYearRange();\n        }\n\n        if (month < 1 || month > 12) {\n            revert InvalidMonthRange();\n        }\n\n        // Year.\n        for (i = 1970; i < year; i++) {\n            if (isLeapYear(i)) {\n                timestamp += 366 days;\n            } else {\n                timestamp += 365 days;\n            }\n        }\n\n        // Month.\n        uint8[12] memory monthDayCounts;\n        monthDayCounts[0] = 31;\n        if (isLeapYear(year)) {\n            monthDayCounts[1] = 29;\n        } else {\n            monthDayCounts[1] = 28;\n        }\n        monthDayCounts[2] = 31;\n        monthDayCounts[3] = 30;\n        monthDayCounts[4] = 31;\n        monthDayCounts[5] = 30;\n        monthDayCounts[6] = 31;\n        monthDayCounts[7] = 31;\n        monthDayCounts[8] = 30;\n        monthDayCounts[9] = 31;\n        monthDayCounts[10] = 30;\n        monthDayCounts[11] = 31;\n\n        if (day < 1 || day > monthDayCounts[month - 1]) {\n            revert InvalidDayRange();\n        }\n\n        for (i = 1; i < month; i++) {\n            timestamp += monthDayCounts[i - 1] * 1 days;\n        }\n\n        // Day.\n        timestamp += (day - 1) * 1 days;\n\n        return timestamp;\n    }\n\n    /**\n     * @notice Checks whether a given year is a leap year.\n     * @param year The year to check.\n     * @return True if the year is a leap year, otherwise false.\n     */\n    function isLeapYear(uint256 year) internal pure returns (bool) {\n        if (year < 1970 || year > 2100) {\n            revert InvalidYearRange();\n        }\n\n        if (year % 4 != 0) {\n            return false;\n        } else if (year % 100 != 0) {\n            return true;\n        } else if (year % 400 != 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n"
      },
      "npm/@selfxyz/contracts@1.2.0/contracts/libraries/SelfStructs.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\n/**\n * @title SelfStructs\n * @dev Library containing data structures for Self protocol identity verification\n * @notice Defines structs for passport verification, EU ID verification, and generic disclosure outputs\n */\nlibrary SelfStructs {\n    /**\n     * @dev Header structure for Hub input containing contract version and scope information\n     * @param contractVersion Version of the contract being used\n     * @param scope Scope identifier for the verification request\n     * @param attestationId Unique identifier for the attestation\n     */\n    struct HubInputHeader {\n        uint8 contractVersion;\n        uint256 scope;\n        bytes32 attestationId;\n    }\n\n    /**\n     * @dev Output structure for passport verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     */\n    struct PassportOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /**\n     * @dev Output structure for EU ID verification results\n     * @param attestationId Unique identifier for the attestation\n     * @param revealedDataPacked Packed binary data of revealed information\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     */\n    struct EuIdOutput {\n        uint256 attestationId;\n        bytes revealedDataPacked;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n    }\n\n    /// @dev OFAC verification mode: Passport number only\n    uint256 constant passportNoOfac = 0;\n    /// @dev OFAC verification mode: Name and date of birth\n    uint256 constant nameAndDobOfac = 1;\n    /// @dev OFAC verification mode: Name and year of birth\n    uint256 constant nameAndYobOfac = 2;\n\n    /**\n     * @dev Generic disclosure output structure (Version 2) with detailed personal information\n     * @param attestationId Unique identifier for the attestation\n     * @param userIdentifier Unique identifier for the user\n     * @param nullifier Cryptographic nullifier to prevent double-spending\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param issuingState Country or state that issued the document\n     * @param name Array of name components (first, middle, last names)\n     * @param idNumber Government-issued identification number\n     * @param nationality Nationality of the document holder\n     * @param dateOfBirth Date of birth in string format\n     * @param gender Gender of the document holder\n     * @param expiryDate Document expiration date in string format\n     * @param olderThan Minimum age verification result\n     * @param ofac Array of OFAC (Office of Foreign Assets Control) verification results for different modes\n     */\n    struct GenericDiscloseOutputV2 {\n        bytes32 attestationId;\n        uint256 userIdentifier;\n        uint256 nullifier;\n        uint256[4] forbiddenCountriesListPacked;\n        string issuingState;\n        string[] name;\n        string idNumber;\n        string nationality;\n        string dateOfBirth;\n        string gender;\n        string expiryDate;\n        uint256 olderThan;\n        bool[3] ofac;\n    }\n\n    /**\n     * @dev Verification configuration structure (Version 1)\n     * @param olderThanEnabled Whether minimum age verification is enabled\n     * @param olderThan Minimum age requirement\n     * @param forbiddenCountriesEnabled Whether forbidden countries check is enabled\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param ofacEnabled Array of boolean flags for different OFAC verification modes\n     */\n    struct VerificationConfigV1 {\n        bool olderThanEnabled;\n        uint256 olderThan;\n        bool forbiddenCountriesEnabled;\n        uint256[4] forbiddenCountriesListPacked;\n        bool[3] ofacEnabled;\n    }\n\n    /**\n     * @dev Verification configuration structure (Version 2)\n     * @param olderThanEnabled Whether minimum age verification is enabled\n     * @param olderThan Minimum age requirement\n     * @param forbiddenCountriesEnabled Whether forbidden countries check is enabled\n     * @param forbiddenCountriesListPacked Packed list of forbidden countries (4 uint256 array)\n     * @param ofacEnabled Array of boolean flags for different OFAC verification modes\n     */\n    struct VerificationConfigV2 {\n        bool olderThanEnabled;\n        uint256 olderThan;\n        bool forbiddenCountriesEnabled;\n        uint256[4] forbiddenCountriesListPacked;\n        bool[3] ofacEnabled;\n    }\n}\n"
      },
      "project/contracts/UserVerification.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {SelfVerificationRoot} from \"@selfxyz/contracts/contracts/abstract/SelfVerificationRoot.sol\";\nimport {ISelfVerificationRoot} from \"@selfxyz/contracts/contracts/interfaces/ISelfVerificationRoot.sol\";\nimport {SelfStructs} from \"@selfxyz/contracts/contracts/libraries/SelfStructs.sol\";\nimport {Formatter} from \"@selfxyz/contracts/contracts/libraries/Formatter.sol\";\n\n/**\n * @title TestSelfVerificationRoot\n * @notice Test implementation of SelfVerificationRoot for testing purposes\n * @dev This contract provides a concrete implementation of the abstract SelfVerificationRoot\n */\ncontract UserVerification is SelfVerificationRoot {\n    // Storage for testing purposes\n    bool public verificationSuccessful;\n    ISelfVerificationRoot.GenericDiscloseOutputV2 public lastOutput;\n    bytes public lastUserData;\n    SelfStructs.VerificationConfigV2 public verificationConfig;\n    bytes32 public verificationConfigId;\n    address public lastUserAddress;\n\n    //Define Error\n    error LogError(string[] namesArray);\n    error UserIdentifierMismatch(uint256 expectedValue, uint256 actualValue);\n\n    // Added Information\n    uint256 public lastUserIdentifier;\n    \n    mapping (address => BeneficiaryInfo) beneficiaryData; \n\n    struct BeneficiaryInfo {\n        uint256[] beneficiaryUserIdentifier;\n    }\n\n    // Added Events\n    event AddedBeneficiary(\n        address ascendAddress,\n        uint256[] beneficiaryUserIdentifiers\n    );\n\n    event RemovedBeneficiaryUserIdentifier(\n        address ascendAddress,\n        uint256 beneficiaryUserIdentifier\n    );\n\n    event StringLogEvent(\n        string log    \n    );\n    \n    event ByteLogEvent(\n        bytes log    \n    );\n\n    event Uint256LogEvent(\n        uint256 log\n    );\n\n    event AddressParsingEvent(\n        address parsedAddress,\n        bytes originalUserData\n    );\n\n    constructor(\n        address identityVerificationHubV2Address,\n        uint256 scope,\n        bytes32 _verificationConfigId\n    ) SelfVerificationRoot(identityVerificationHubV2Address, scope) {\n        verificationConfigId = _verificationConfigId;\n    }\n\n    //Helper Functions\n\n    function addBeneficiaryData(address _ascendAddress, uint256[] memory _beneficiaryUserIdentifiers) external {\n        for (uint256 j = 0; j < _beneficiaryUserIdentifiers.length; j++) {\n                beneficiaryData[_ascendAddress].beneficiaryUserIdentifier.push(_beneficiaryUserIdentifiers[j]);\n            }\n        emit AddedBeneficiary(_ascendAddress, _beneficiaryUserIdentifiers);\n    }\n\n    function addBeneficiaryDataBatch(\n        address[] calldata _ascendAddresses, \n        uint256[][] calldata _beneficiaryUserIdentifiers\n    ) external {\n        require(_ascendAddresses.length == _beneficiaryUserIdentifiers.length, \"Arrays length mismatch\");\n        \n        for (uint256 i = 0; i < _ascendAddresses.length; i++) {\n            address addr = _ascendAddresses[i];\n            uint256[] calldata identifiers = _beneficiaryUserIdentifiers[i];\n            \n            for (uint256 j = 0; j < identifiers.length; j++) {\n                beneficiaryData[addr].beneficiaryUserIdentifier.push(identifiers[j]);\n            }\n            emit AddedBeneficiary(addr, identifiers);\n        }\n    }\n\n    function getBeneficiaryData(address _address) public view returns (BeneficiaryInfo memory) {\n        return beneficiaryData[_address];\n    }\n\n    /* Function which needs to be called from the smart contract that handles the releasing of the funds, \n    once the funds have been released to the corresponding user. To make sure that no other beneficiary can claim using the same ZK Proof.\n    */\n    function removeBeneficiaryUserIdentifier(address _ascendAddress, uint256 _beneficiaryUserIdentifier) external {\n        uint256[] storage identifiers = beneficiaryData[_ascendAddress].beneficiaryUserIdentifier;\n        \n        // Find and remove the identifier\n        for (uint256 i = 0; i < identifiers.length; i++) {\n            if (identifiers[i] == _beneficiaryUserIdentifier) {\n                // Move the last element to the current position and remove the last element\n                identifiers[i] = identifiers[identifiers.length - 1];\n                identifiers.pop();\n                break;\n            }\n        }\n        \n        emit RemovedBeneficiaryUserIdentifier(_ascendAddress, _beneficiaryUserIdentifier);\n    }\n\n    function verifyUserData(address ascendAddress) internal view {        \n        // Get the allowed beneficiary user identifiers for this ascend\n        uint256[] memory allowedBeneficiaryUserIdentifier = beneficiaryData[ascendAddress].beneficiaryUserIdentifier;\n        \n        // Check if lastUserIdentifier exists in the allowed list\n        bool isAllowed = false;\n        for (uint256 i = 0; i < allowedBeneficiaryUserIdentifier.length; i++) {\n            if (allowedBeneficiaryUserIdentifier[i] == lastUserIdentifier) {\n                isAllowed = true;\n                break;\n            }\n        }\n        \n        if (!isAllowed) {\n            revert UserIdentifierMismatch(0, lastUserIdentifier); // 0 indicates \"not found in allowed list\"\n        } \n    }\n\n    function testverifyUserData(address ascendAddress) internal {        \n        // Get the allowed beneficiary user identifiers for this ascend\n        uint256[] memory allowedBeneficiaryUserIdentifier = beneficiaryData[ascendAddress].beneficiaryUserIdentifier;\n        \n        // Check if lastUserIdentifier exists in the allowed list\n        bool isAllowed = false;\n        for (uint256 i = 0; i < allowedBeneficiaryUserIdentifier.length; i++) {\n            if (allowedBeneficiaryUserIdentifier[i] == lastUserIdentifier) {\n                isAllowed = true;\n                break;\n            }\n        }\n        \n        if (!isAllowed) {\n            emit StringLogEvent(\"Check_Failed\");\n        } else {\n            emit StringLogEvent(\"Check_Successfull\");\n        }\n    }\n\n\n    /**\n     * @notice Implementation of customVerificationHook for testing\n     * @dev This function is called by onVerificationSuccess after hub address validation\n     * @param output The verification output from the hub\n     * @param userData The user data passed through verification\n     */\n    function customVerificationHook(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) internal override {\n        verificationSuccessful = true;\n        lastUserIdentifier = output.nullifier;\n        \n        //emit ByteLogEvent(userData);\n        emit Uint256LogEvent(lastUserIdentifier);\n\n        // Parse userData to address\n        address ascendAddress = parseAddressFromUserData(userData);\n        emit AddressParsingEvent(ascendAddress, userData);\n        \n        // Now you can use the parsed address\n        // For example, call verifyUserData with the parsed address\n        testverifyUserData(ascendAddress);\n    }\n\n    function testCustomVerification(\n        ISelfVerificationRoot.GenericDiscloseOutputV2 memory output,\n        bytes memory userData\n    ) external {\n        customVerificationHook(output, userData);\n    } \n\n    /**\n     * @notice Parse address from userData bytes\n     * @dev Handles both ABI-encoded addresses and hex string addresses\n     * @param userData The user data containing the address\n     * @return The parsed address\n     */\n    function parseAddressFromUserData(bytes memory userData) internal pure returns (address) {\n        // First, try to decode as ABI-encoded address (20 bytes)\n        if (userData.length == 32) {\n            // Standard ABI encoding of address (padded to 32 bytes)\n            return abi.decode(userData, (address));\n        } else if (userData.length == 20) {\n            // Raw address bytes (20 bytes)\n            return address(bytes20(userData));\n        } else if (userData.length == 42) {\n            // Hex string format: \"0x\" + 40 hex chars = 42 chars\n            return parseHexStringToAddress(userData);\n        } else if (userData.length == 40) {\n            // Hex string without \"0x\" prefix = 40 chars\n            return parseHexStringToAddress(userData);\n        } else {\n            revert(\"Invalid userData format for address parsing\");\n        }\n    }\n\n    /**\n     * @notice Parse hex string to address\n     * @dev Converts hex string bytes to address\n     * @param hexString The hex string as bytes\n     * @return The parsed address\n     */\n    function parseHexStringToAddress(bytes memory hexString) internal pure returns (address) {\n        require(hexString.length == 40 || hexString.length == 42, \"Invalid hex string length\");\n        \n        uint256 startIndex = 0;\n        if (hexString.length == 42) {\n            // Skip \"0x\" prefix\n            require(hexString[0] == 0x30 && hexString[1] == 0x78, \"Invalid hex prefix\");\n            startIndex = 2;\n        }\n        \n        bytes20 addressBytes;\n        for (uint256 i = 0; i < 20; i++) {\n            uint8 high = hexCharToByte(hexString[startIndex + i * 2]);\n            uint8 low = hexCharToByte(hexString[startIndex + i * 2 + 1]);\n            addressBytes |= bytes20(bytes1(high * 16 + low)) >> (i * 8);\n        }\n        \n        return address(addressBytes);\n    }\n\n    /**\n     * @notice Convert hex character to byte value\n     * @dev Converts ASCII hex character to its byte value\n     * @param hexChar The hex character as byte\n     * @return The byte value (0-15)\n     */\n    function hexCharToByte(bytes1 hexChar) internal pure returns (uint8) {\n        uint8 char = uint8(hexChar);\n        if (char >= 48 && char <= 57) {\n            // '0' - '9'\n            return char - 48;\n        } else if (char >= 65 && char <= 70) {\n            // 'A' - 'F'\n            return char - 55;\n        } else if (char >= 97 && char <= 102) {\n            // 'a' - 'f'\n            return char - 87;\n        } else {\n            revert(\"Invalid hex character\");\n        }\n    }\n\n    /**\n     * @notice Reset the test state\n     */\n    function resetTestState() external {\n        verificationSuccessful = false;\n        lastOutput = ISelfVerificationRoot.GenericDiscloseOutputV2({\n            attestationId: bytes32(0),\n            userIdentifier: 0,\n            nullifier: 0,\n            forbiddenCountriesListPacked: [\n                uint256(0),\n                uint256(0),\n                uint256(0),\n                uint256(0)\n            ],\n            issuingState: \"\",\n            name: new string[](3),\n            idNumber: \"\",\n            nationality: \"\",\n            dateOfBirth: \"\",\n            gender: \"\",\n            expiryDate: \"\",\n            olderThan: 0,\n            ofac: [false, false, false]\n        });\n        lastUserData = \"\";\n        lastUserAddress = address(0);\n    }\n\n    function setScope(uint256 newScope) external {\n        _setScope(newScope);\n    }\n\n    function setVerificationConfig(\n        SelfStructs.VerificationConfigV2 memory config\n    ) external {\n        verificationConfig = config;\n        _identityVerificationHubV2.setVerificationConfigV2(verificationConfig);\n    }\n\n    function setVerificationConfigNoHub(\n        SelfStructs.VerificationConfigV2 memory config\n    ) external {\n        verificationConfig = config;\n    }\n\n    function setConfigId(bytes32 configId) external {\n        verificationConfigId = configId;\n    }\n\n    function getConfigId(\n        bytes32 /* destinationChainId */,\n        bytes32 /* userIdentifier */,\n        bytes memory /* userDefinedData */\n    ) public view override returns (bytes32) {\n        return verificationConfigId;\n    }\n}\n"
      }
    }
  }
}